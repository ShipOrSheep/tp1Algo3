\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish]{babel} % para que comandos como \today den el resultado en castellano
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage{caratula}
% \usepackage[left=3cm,right=3cm,bottom=3cm,top=3cm]{geometry}

% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb, tabularx}

% Comandos para referencias
\usepackage[square,numbers]{natbib}

% Comandos para Figuras, Graficos, Tikz etc.
\usepackage{tikz}
\usepackage{epsfig}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{svg}

% Comandos para teoremas etc.
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{proposition}[theorem]{Proposición}
\newtheorem{remark}{Observación}
\newtheorem{corollary}{Corolario}
% \newproof{proof}{Demostración}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
\State \algorithmicif\ #1\ \algorithmicthen\ #2\ \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
  \State \algorithmicif\ #1\ \algorithmicthen\ #2}

\begin{document}

\titulo{TP1: Optimizando Jambo-tubos}

\subtitulo{}

\fecha{\today}

\materia{Algoritmos y Estructuras de datos III}

\integrante{Oshiro, Javier Esteban}{715/09}{javieroshiro@hotmail.com}
\integrante{Castro, Jonatan Daniel}{63/18}{jonatan.dan@hotmail.com}

\maketitle

\tableofcontents

\newpage

\setcounter{page}{1}

\section{Introducción} \label{sec:introduccion}
En este trabajo práctico trabajamos con Jambo-tubos, este es un servicio de la cadena de supermercados Jambo que cuenta con un robot que tiene como objetivo decidir qué productos de los que llegan por una cinta transportadora serán incluidos en un tubo con la idea de lograr la mayor cantidad de productos entubados. Cada producto llega por la cinta en un orden determinado, y se conoce su peso y resistencia individual, por lo que el robot debe manejar esta información para no romper el tubo ni los productos apilados dentro del mismo por el propio peso de cada uno. \cite{ref:enunciado}

Durante el informe desarrollaremos tres técnicas de programación que nos permitirán abordar el problema de los Jambo-tubos: Fuerza Bruta(FB), Backtracking(BT), y por último Programación Dinámica(PD).

\section{Fuerza Bruta} \label{sec:fuerza_bruta}
El algoritmo de Fuerza Bruta recorre todas las posibles soluciones sin importar que sean factibles o no, en el caso de Jambo-tubos se tendrán en cuenta todas las posibles formas de meter los productos en el tubo, luego se determinará cuál es la cantidad máxima de productos que se pueden ingresar sin romper el tubo ni los productos apilados.

\subsection{Implementación y correctitud}
El algoritmo implementado es recursivo y en cada paso se revisarán dos posibilidades sobre el producto actual en cinta, se agrega o no al tubo. Esto genera todo el árbol de recursión con todos los casos posibles, o sea todas las ramas completas, siendo sus hojas las posibles soluciones, esto nos garantiza la correctitud del algoritmo. Finalmente teniendo todas las posibles soluciones basta con seleccionar la que cumple que maximiza la cantidad de productos ingresados al tubo sin romper el tubo ni los productos apilados.

Para saber si se rompe algún producto dentro del Jambo-tubo guardamos en una variable la mínima resistencia restante entre los productos, para ello calculamos en cada paso el mínimo entre el nuevo producto agregado y la diferencia entre la resistencia mínima restante y el peso del nuevo producto. De esta forma siempre estamos verificando que el producto de menor resistencia restante no se rompa, asegurando el estado del resto de los productos de mayor resistencia. Si se rompe el elemento de menor resistencia restante luego ya sabemos que ese caso hay que descartarlo.

\begin{algorithm}
	\begin{algorithmic}[1]
		\Function{$FB$}{$i$, $W$, $k$, $minR$, $aplastados$}

		\If{$i = n$}
			\IfThenElse{$W <= R$ $\land$ $!aplastados$}{\textbf{return} $k$}{\textbf{return} $0$}
		\EndIf
		
		\State $aplastadosAux \leftarrow aplastados$ $||$ $(minR - w[i] < 0)$ 
		
		\State \textbf{return} $\max \{ FB(i+1, W, k, minR, aplastados), FB(i+1, W+w[i], k+1, min(minR - w[i], r[i]), aplastadosAux)) \}$.

		\EndFunction
	\end{algorithmic}
	\caption{Algoritmo de Fuerza Bruta.}
	\label{alg:fuerza_bruta}
\end{algorithm} 	

\subsection{Complejidad}
La complejidad del algoritmo es $O(2^n)$ para el peor caso, pues en cada paso recursivo genera dos llamados la misma función, una para el caso en que se agrega el producto al tubo, y otra para el caso en que no. El árbol de recursión completo cuenta con $n + 1$ niveles contando la raíz, y siendo cada hoja una solución posible. La cantidad de nodos nos indica la cantidad de llamados recursivos realizados que son exactamente $2^n$.
El resto de las operaciones elementales y comparaciones se realizan en $\theta(1)$.

\section{Backtracking} \label{sec:backtracking}
Similar al algoritmo de fuerza bruta, intenta recorrer el árbol de recursión con todas las posibles combinaciones pero evitando revisar algunas ramas según una poda que puede ser por factibilidad en caso de que esa rama no lleve a una solución factible, o por optimalidad en caso de que esa rama no lleve a una solución optima. Por la propiedad dominó podemos asegurarnos que ninguna solución del sub-árbol generado por el nodo sobre el que se aplica la poda lleva a una solución esperada.

\subsection{Implementación y correctitud}
En este caso la correctitud es similar a la de Fuerza Bruta ya que el algoritmo sólo agrega sobre este último podas que finalizan la búsqueda de soluciones por la rama que está siendo evaluada. Estas podas se implementan como filtros.

\paragraph{Poda por factibilidad}
Implementada sobre la idea de evitar continuar con ramas en que la suma de los pesos de los productos en el Jambo-tubo superen la resistencia total del mismo, o rompan alguno de los productos dentro del tubo.

\paragraph{Poda por optimalidad}
Implementada sobre la idea de evitar continuar por ramas en que sabemos que ingresando en el Jambo-tubo todos los elementos restantes, no llegaremos a superar el número de elementos ingresados óptimo.

\begin{algorithm}
	\begin{algorithmic}[1]
		\Function{$BT$}{$i$, $W$, $k$, $minR$, $kOptimo$}

		\If{$i = n$}
			\IfThenElse{$W <= R$ $\land$ $minR >= 0$}{\textbf{return} $kOptimo$}{\textbf{return} $0$}
		\EndIf
		
		\If{$poda\_factibilidad$ $\land$ $(W > R$ $||$ $minR < 0)$}{ \textbf{return} $0$}\EndIf
		
		\If{$poda\_optimalidad$ $\land$ $(kOptimo > (k + n-i-1))$}{ \textbf{return} $0$}\EndIf
		
		\State \textbf{return} $\max \{ BT(i+1, W, k, minR, kOptimo), BT(i+1, W+w[i], k+1, min(minR - w[i], r[i]), max(kOptimo, k+1))) \}$.
		
		\EndFunction
	\end{algorithmic}
	\caption{Algoritmo de Backtracking.}
	\label{alg:backtracking}
\end{algorithm}

\subsection{Complejidad}
La implementación es igual a la del algoritmo de Fuerza Bruta pero en cada paso se verifican las dos condiciones para las podas, por lo que sigue teniendo peor caso con complejidad $O(2^n)$ sumado a la complejidad propia de cada poda. Teniendo podas que se resuelven con operaciones elementales y comparaciones en $\theta(1)$, no se agrega complejidad adicional.

\section{Programación Dinámica} \label{sec:dp}
La programación dinámica tiene como característica evitar calcular valores que ya fueron computados en pasos siguientes. Por la naturaleza recursiva de un problema podemos tener casos en que un sub-árbol se calcule más de una única vez generando cómputo innecesario. En programación dinámica podemos resolver este problema utilizando un diccionario que contenga todos los valores calculados hasta el momento para poder reutilizarlos.

\subsection{Implementación y correctitud}
La implementación es recursiva y similar a la de los métodos anteriores, con el agregado de que al momento de hacer el paso recursivo se verifica que no se haya computado ya. Si se calculó, no se entra al paso, sino que se obtiene el valor a través de una matriz de memoización. Los casos base serían: cuando el peso actual aplasta un elemento de abajo o destruye el jambotubo, o cuando se llega al final de la cinta transportadora. \newline 
El paso recursivo en realidad comprende dos casos: cuando agregamos el elemento actual, y cuando no lo agregamos. En cada paso se tiene $i$ el indicador de en qué elemento de la cinta voy a tomar la decisión de meter o no en el jambotubo, y se tiene $Ractual$ la resistencia acumulada. La resistencia acumulada es la mínima resistencia necesaria para romper el jambotubo o para aplastar algún elemento: si el peso del elemento actual sobrepasa $Ractual$, algo salió mal. La resistencia acumulada se elige como el mínimo entre la resistencia del elemento que estoy metiendo, y la resistencia anterior menos el peso del elemento actual.
\paragraph{Memoización}
La estructura de memoización utilizada es una matriz que tiene por tamaño de fila la cantidad total de elementos de la cinta, y por tamaño de columna la resistencia del jambotubo. Cada valor de la matriz corresponde con el máximo número de elementos ingresados en el Jambo-tubo en el paso $i$ con la resistencia acumulada $Ractual$ resultante de haber metido o no elementos anteriores. Esta forma de definir las filas y columnas se corresponde con la aridad de nuestra función.
La memoización se da cuando en distintas ramas de la ejecución del algoritmo, en un paso $i$, se repite el valor de la resistencia acumulada. Un ejemplo de esto puede ser una instancia en donde el segundo elemento es igual en resistencia y peso al tercer elemento. Luego, van a haber una rama en donde no se agregue el segundo elemento y sí el tercero, y va a existir otra rama en donde se haga lo contrario. Como las ramas coinciden en Resistencia acumulada va a entrar en juego la memoización.
% Cambiamos de algoritmo
\begin{algorithm}
	\begin{algorithmic}[1]
		\Function{$PD$}{$i$, $Ractual$}
		
		\If{$Ractual$ < $0$}{\textbf{return} $-1$}\EndIf

		\If{$i = n$}{\textbf{return} $0$}\EndIf
		
		\If{$m[i][W] == -1$}{$Rproxima = min(Ractual - w[i], r[i])$$m[i][W] \leftarrow max(DP(i+1, Ractual), DP(i+1, Rproxima))$}\EndIf
		
		\State \textbf{return} $m[i][W]$.
		
		\EndFunction
	\end{algorithmic}
	\caption{Algoritmo de Programación Dinámica.}
	\label{alg:dinamica}
\end{algorithm}

\subsection{Complejidad}
La complejidad del algoritmo de programación dinámica está determinada por la cantidad de estados que se resuelven y el costo de resolver cada uno de ellos.
Sabemos que la matriz tiene una dimensión de $n * R$ que es la cantidad de elementos por la resistencia total del tubo. Para inicializar la matriz insumimos $O(n * R)$ y en el algoritmo a lo sumo se resuelven $O(n * R)$ estados distintos que equivale a completar la matriz. Como las operaciones son elementales o calcular un máximo entonces cada cálculo se resuelve en $\theta(1)$. Finalmente el algoritmo tiene complejidad $O(n * R)$ en el peor caso.

\section{Experimentación} \label{sec:experimentacion}

\subsection{Métodos}

\subsection{Instancias}

%EXPERIMENTOS
%\subsection{Experimento 1}
%\subsection{Experimento 2}
%\subsection{Experimento 3}

\section{Conclusiones} \label{sec:conclusiones}

\newpage

\bibliographystyle{abbrvnat} % estilo de bibliografia
\bibliography{referencias} % importa bib

\end{document}
