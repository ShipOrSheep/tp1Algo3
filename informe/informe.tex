\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish]{babel} % para que comandos como \today den el resultado en castellano
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage{caratula}
% \usepackage[left=3cm,right=3cm,bottom=3cm,top=3cm]{geometry}

% Comandos para simbolos matematicos.
\usepackage{amsmath, amssymb, tabularx}

% Comandos para referencias
\usepackage[square,numbers]{natbib}

% Comandos para Figuras, Graficos, Tikz etc.
\usepackage{tikz}
\usepackage{epsfig}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{svg}

% Comandos para teoremas etc.
\usepackage{amsthm}
\newtheorem{theorem}{Teorema}
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{proposition}[theorem]{Proposición}
\newtheorem{remark}{Observación}
\newtheorem{corollary}{Corolario}
% \newproof{proof}{Demostración}

% Comandos para algoritmos.
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand{\IfThenElse}[3]{% \IfThenElse{<if>}{<then>}{<else>}
\State \algorithmicif\ #1\ \algorithmicthen\ #2\ \algorithmicelse\ #3}
\algnewcommand{\IfThen}[2]{% \IfThenElse{<if>}{<then>}
  \State \algorithmicif\ #1\ \algorithmicthen\ #2}

\begin{document}

\titulo{TP1: Optimizando Jambo-tubos}

\subtitulo{}

\fecha{\today}

\materia{Algoritmos y Estructuras de datos III}

\integrante{Oshiro, Javier Esteban}{715/09}{javieroshiro@hotmail.com}
\integrante{Castro, Jonatan Daniel}{63/18}{jonatan.dan@hotmail.com}

\maketitle

\tableofcontents

\newpage

\setcounter{page}{1}

\section{Introducción} \label{sec:introduccion}
En este trabajo práctico trabajamos con Jambo-tubos, este es un servicio de la cadena de supermercados Jambo que cuenta con un robot que tiene como objetivo decidir qué productos de los que llegan por una cinta transportadora serán incluidos en un tubo con la idea de lograr la mayor cantidad de productos entubados. Cada producto llega por la cinta en un orden determinado, y se conoce su peso y resistencia individual, por lo que el robot debe manejar esta información para no romper el tubo ni los productos apilados dentro del mismo por el propio peso de cada uno. \cite{ref:enunciado}

Durante el informe desarrollaremos tres técnicas de programación que nos permitirán abordar el problema de los Jambo-tubos: Fuerza Bruta(FB), Backtracking(BT), y por último Programación Dinámica(PD).

\section{Fuerza Bruta} \label{sec:fuerza_bruta}
EL algoritmo de Fuerza Bruta recorre todas las posibles soluciones sin importar que sean factibles o no, en el caso de Jambo-tubos se tendrán en cuenta todas las posibles formas de meter los productos en el tubo, luego se determinará cuál es la cantidad máxima de productos que se pueden ingresar sin romper el tubo ni los productos apilados.

\subsection{Implementación y correctitud}
El algoritmo implementado es recursivo y en cada paso se revisarán dos posibilidades sobre el producto actual en cinta, se agrega o no al tubo. Esto genera todo el árbol de recursión con todos los casos posibles, o sea todas las ramas completas, siendo sus hojas las posibles soluciones, esto nos garantiza la correctitud del algoritmo. Finalmente teniendo todas las posibles soluciones basta con seleccionar la que cumple que maximiza la cantidad de productos ingresados al tubo sin romper el tubo ni los productos apilados.

Para saber si se rompe algún producto dentro del Jambo-tubo guardamos en una variable la mínima resistencia restante entre los productos, para ello calculamos en cada paso el mínimo entre el nuevo producto agregado y la diferencia entre la resistencia mínima restante y el peso del nuevo producto. De esta forma siempre estamos verificando que el producto de menor resistencia restante no se rompa, asegurando el estado del resto de los productos de mayor resistencia. Si se rompe el elemento de menor resistencia restante luego ya sabemos que ese caso hay que descartarlo.

\begin{algorithm}
	\begin{algorithmic}[1]
		\Function{$FB$}{$i$, $W$, $k$, $minR$, $aplastados$}

		\If{$i = n$}
			\IfThenElse{$W <= R$ $\land$ $!aplastados$}{\textbf{return} $k$}{\textbf{return} $\infty$}
		\EndIf
		
		\State $aplastadosAux \impliedby aplastados$ $||$ $(minR - w[i] < 0)$ 
		
		\State \textbf{return} $\min \{ FB(i+1, W, k, minR, aplastados), FB(i+1, W+w[i], k+1, min(minR - w[i], r[i]), aplastadosAux)) \}$.

		\EndFunction
	\end{algorithmic}
	\caption{Algoritmo de Fuerza Bruta.}
	\label{alg:fuerza_bruta}
\end{algorithm} 	

\subsection{Complejidad}
La complejidad del algoritmo es $O(2^n)$ para el peor caso, pues en cada paso recursivo genera dos llamados la misma función, una para el caso en que se agrega el producto al tubo, y otra para el caso en que no. El árbol de recursión completo cuenta con $n + 1$ niveles contando la raíz, y siendo cada hoja una solución posible. La cantidad de nodos nos indica la cantidad de llamados recursivos realizados que son exactamente $2^n$.
El resto de las operaciones elementales y comparaciones se realizan en $\theta(1)$.

\section{Backtracking} \label{sec:backtracking}
Similar al algoritmo de fuerza bruta, intenta recorrer el árbol de recursión con todas las posibles combinaciones pero evitando revisar algunas ramas según una poda que puede ser por factibilidad en caso de que esa rama no lleve a una solución factible, o por optimalidad en caso de que esa rama no lleve a una solución optima.

\subsection{Implementación y correctitud}
En este caso la correctitud es similar a la de Fuerza Bruta ya que el algoritmo solo agrega sobre este último podas que finalizan la búsqueda de soluciones por la rama que está siendo evaluada. Estas podas se implementan como filtros.

\paragraph{Poda por factibilidad}
Implementada sobre la idea de evitar continuar con ramas en que la suma de los pesos de los productos en el Jambo-tubo superen la resistencia total del mismo.

\paragraph{Poda por optimalidad}
Implementada sobre la idea de evitar continuar por ramas en que sabemos que ingresando en el Jambo-tubo todos los elementos restantes, no llegaremos a superar el número de elementos ingresados óptimo.

\begin{algorithm}
	\begin{algorithmic}[1]
		\Function{$BT$}{$i$, $W$, $k$, $minR$, $kOptimo$}

		\If{$i = n$}
			\IfThenElse{$W <= R$ $\land$ $minR >= 0$}{\textbf{return} $kOptimo$}{\textbf{return} $\infty$}
		\EndIf
		
		\If{$poda\_factibilidad$ $\land$ $(W > R$ $||$ $minR < 0)$}{ \textbf{return} $\infty$}\EndIf
		
		\If{$poda\_optimalidad$ $\land$ $(kOptimo > (k + n-i-1))$}{ \textbf{return} $\infty$}\EndIf
		
		\State \textbf{return} $\min \{ BT(i+1, W, k, minR, kOptimo), BT(i+1, W+w[i], k+1, min(minR - w[i], r[i]), max(kOptimo, k+1))) \}$.
		
		\EndFunction
	\end{algorithmic}
	\caption{Algoritmo de Backtracking.}
	\label{alg:backtracking}
\end{algorithm}

\subsection{Complejidad}
La implementación es igual a la del algoritmo de Fuerza Bruta pero en cada paso se verifican las dos condiciones para las podas, por lo que sigue teniendo pero caso con complejidad $O(2^n)$. Teniendo podas que se resuelven con operaciones elementales y comparaciones en $\theta(1)$, no se agrega complejidad adicional.

\section{Programación Dinámica} \label{sec:dp}

\subsection{Implementación y correctitud}

\subsection{Complejidad}

\subsection{Memoización}

\section{Experimentación} \label{sec:experimentacion}

\subsection{Métodos}

\subsection{Instancias}

%EXPERIMENTOS
%\subsection{Experimento 1}
%\subsection{Experimento 2}
%\subsection{Experimento 3}

\section{Conclusiones} \label{sec:conclusiones}

\newpage

\bibliographystyle{abbrvnat} % estilo de bibliografia
\bibliography{referencias} % importa bib

\end{document}
